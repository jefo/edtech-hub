# DDD Трансформация: от "Service-Oriented" к "Domain-Driven" мышлению

## Введение

Данный документ описывает трансформацию разработчика от состояния "понимаю, что что-то не так с бизнес-логикой в сервисах, но не могу понять что именно" к состоянию "мыслю терминами DDD и проектирую домен-ориентированные системы".

**Целевая трансформация:**
Service-Oriented мышление → Domain-Driven мышление

---

## 1. Анализ стартового состояния (S₀)

### 1.1 Профиль разработчика "до" трансформации

**Технические навыки (есть):**
- Умеет писать код в сервисах
- Понимает HTTP API, базы данных, фреймворки
- Может реализовать CRUD операции
- Знает основы архитектурных паттернов

**Проблемные зоны (симптомы):**
- Вся бизнес-логика размазана по сервисам
- "Толстые" контроллеры с прямыми вызовами к БД
- Дублирование логики между разными эндпоинтами
- Сложность в тестировании бизнес-правил
- Запутанные зависимости между компонентами
- Страх вносить изменения ("а что сломается?")

**Ментальная модель:**
```
Request → Controller → Service → Database → Response
```

**Мыслит категориями:**
- "Сделаю еще один сервис"
- "Добавлю поле в таблицу"
- "Вызову API другого сервиса"
- "Обработаю это в контроллере"

---

## 2. Целевое состояние (S★)

### 2.1 Профиль DDD-разработчика

**Мыслит терминами:**
- **Аггрегаты/Сущности/Value Objects** — четкое понимание границ и ответственности
- **Границы ответственности** — кто за что отвечает в системе
- **Атомарность/Транзакционность** — понимание consistency boundaries
- **CQRS для предметной области** — разделение чтения и записи на уровне домена
- **Единый источник правды** — одно место для одного бизнес-правила
- **Application Services как оркестрация** — координация, а не бизнес-логика
- **Формальные критерии проектирования** — не "как кажется", а по четким правилам

**Подход к проектированию:**
- **Top-Down от Use Case** — начинаем с пользовательской ценности
- **От Application Service к Домену** — сначала оркестрация, потом реализация
- **Итеративный рефакторинг** — не боится менять границы аггрегатов
- **Trade-off осознанность** — понимает последствия решений

**Ментальная модель:**
```
Use Case → Application Service → Domain Model → Infrastructure
     ↓           ↓                    ↓              ↓
User Intent → Orchestration → Business Rules → Technical Details
```

---

## 3. DDD DACUM: Функции и задачи

### A. Моделирование предметной области (Domain Modeling)

**A1. Выявление Аггрегатов**
- Определение границ консистентности (consistency boundaries)
- Выделение корневых сущностей (aggregate roots)
- Проверка инвариантов на уровне аггрегата
- Минимизация размера аггрегата

**A2. Проектирование Сущностей**
- Определение идентичности объектов
- Разделение на Entity vs Value Object
- Проектирование жизненного цикла сущности
- Инкапсуляция бизнес-правил

**A3. Создание Value Objects**
- Выделение immutable концептов
- Валидация на уровне VO
- Композиция сложных значений
- Типобезопасность домена

### B. Проектирование Application Layer (Application Design)

**B1. Определение Use Cases**
- Анализ пользовательских сценариев
- Выделение бизнес-операций
- Связывание UI потребностей с доменом
- Определение входных/выходных данных

**B2. Создание Application Services**
- Оркестрация доменных операций
- Управление транзакциями
- Интеграция с внешними системами
- Обработка cross-cutting concerns

**B3. Проектирование CQRS**
- Разделение команд и запросов
- Оптимизация читающих моделей
- Проекции для UI нужд
- Event sourcing (при необходимости)

### C. Управление консистентностью (Consistency Management)

**C1. Транзакционные границы**
- Определение atomic operations
- Управление saga паттернами
- Eventual consistency между аггрегатами
- Компенсирующие транзакции

**C2. Доменные события**
- Моделирование бизнес-событий
- Асинхронная обработка
- Integration events vs Domain events
- Event-driven архитектура

**C3. Обеспечение инвариантов**
- Бизнес-правила на уровне домена
- Валидация состояния
- Предотвращение некорректных переходов
- Defensive programming

### D. Рефакторинг и эволюция (Evolution & Refactoring)

**D1. Анализ кода на "запахи"**
- Выявление anemic domain model
- Обнаружение logic leakage
- Поиск дублированной логики
- Анализ coupling/cohesion

**D2. Итеративное улучшение**
- Пошаговый рефакторинг к DDD
- Изменение границ аггрегатов
- Миграция данных при реструктуризации
- Поддержание работоспособности

**D3. Принятие архитектурных решений**
- Trade-off анализ
- Документирование ADR
- Обоснование выбора паттернов
- Оценка технического долга

---

## 4. Уровни DDD мастерства

### Уровень 0: Неосознанная путаница
**Характеристики:**
- Вся логика в сервисах/контроллерах
- Нет понимания доменной модели
- CRUD-thinking everywhere
- "Добавлю еще один сервис" подход

**Индикаторы:**
```java
@Service
class UserService {
    public void updateUserProfile(Long userId, String name, String email) {
        // 50+ строк бизнес-логики прямо здесь
        User user = userRepository.findById(userId);
        // валидация email
        // проверка бизнес-правил
        // отправка уведомлений
        // логирование
        // ...
        userRepository.save(user);
    }
}
```

### Уровень 1: Осознание проблемы
**Характеристики:**
- Понимает, что "что-то не так"
- Знает термины DDD поверхностно
- Пытается выделить доменную модель
- Читает статьи и книги

**Индикаторы:**
- Создает entity классы (но они anemic)
- Пытается создать "доменные" сервисы
- Задает вопросы про аггрегаты
- Экспериментирует с паттернами

### Уровень 2: Базовое понимание
**Характеристики:**
- Может выделить основные аггрегаты
- Понимает разницу Entity/VO
- Создает простые доменные модели
- Использует Application Services

**Индикаторы:**
```java
// Появляется доменная модель
public class Order {
    private OrderId id;
    private CustomerId customerId;
    private List<OrderLine> lines;
    
    public void addLine(ProductId productId, Quantity quantity) {
        // бизнес-правила внутри домена
        validateCanAddLine(productId, quantity);
        lines.add(new OrderLine(productId, quantity));
    }
}

// Application Service как оркестрация
@Service
class OrderApplicationService {
    public void addProductToOrder(AddProductCommand command) {
        Order order = orderRepository.findById(command.orderId());
        order.addLine(command.productId(), command.quantity());
        orderRepository.save(order);
    }
}
```

### Уровень 3: Компетентное применение
**Характеристики:**
- Проектирует от Use Cases
- Четкие границы аггрегатов
- Использует CQRS осознанно
- Управляет консистентностью

**Индикаторы:**
- Top-down проектирование
- Формальные критерии для аггрегатов
- Domain events для интеграции
- Разделение команд и запросов

### Уровень 4: Мастерское владение
**Характеристики:**
- Итеративный подход к границам
- Осознанные trade-offs
- Эволюция архитектуры
- Обучение других

**Индикаторы:**
```java
// Осознанный рефакторинг границ аггрегатов
// Было: Order содержал все
// Стало: Order + OrderFulfillment как отдельные аггрегаты
// Причина: разные жизненные циклы и правила консистентности

@DomainService
class OrderService {
    public OrderId createOrder(CreateOrderCommand command) {
        // Сначала проектируем от Use Case
        Order order = Order.create(
            command.customerId(),
            command.deliveryAddress()
        );
        
        // Проекция в read модель происходит через события
        domainEventPublisher.publish(new OrderCreated(order.getId()));
        
        return orderRepository.save(order).getId();
    }
}
```

### Уровень 5: Экспертное лидерство
**Характеристики:**
- Создает DDD практики в команде
- Архитектурное видение продукта
- Исследует новые подходы
- Ментор по DDD

---

## 5. Ключевые ментальные сдвиги

### 5.1 От "Database-First" к "Domain-First"
**Было:**
"Какие таблицы нужны для этой фичи?"

**Стало:**
"Какие бизнес-правила должна обеспечить эта фича?"

### 5.2 От "Service-Oriented" к "Behavior-Rich Objects"
**Было:**
```java
class UserService {
    void changeEmail(Long userId, String newEmail) { 
        // логика здесь
    }
}
```

**Стало:**
```java
class User {
    void changeEmail(EmailAddress newEmail) {
        // логика внутри объекта
        this.validateEmailChange(newEmail);
        this.email = newEmail;
        this.raise(new EmailChanged(this.id, newEmail));
    }
}
```

### 5.3 От "CRUD everywhere" к "Behavior modeling"
**Было:**
- Create, Read, Update, Delete мышление
- Каждая операция = отдельный endpoint

**Стало:**
- Моделирование бизнес-операций
- "PlaceOrder", "ShipOrder", "CancelOrder"

### 5.4 От "Everything in transaction" к "Consistency boundaries"
**Было:**
"Завернем все в одну большую транзакцию"

**Стало:**
"Что должно быть консистентно немедленно, а что может быть eventually consistent?"

---

## 6. Практические форматы трансформации

### 6.1 Code Review через DDD линзу

**Формат:**
- Еженедельный review кода с фокусом на DDD
- Чек-лист DDD принципов
- Рефакторинг примеры "до/после"

**Чек-лист для Code Review:**
```
□ Есть ли бизнес-логика вне доменной модели?
□ Являются ли аггрегаты поведенческими (не anemic)?
□ Соблюдены ли границы консистентности?
□ Используются ли типы домена вместо примитивов?
□ Отделены ли команды от запросов?
□ Есть ли domain events для важных бизнес-событий?
```

### 6.2 Event Storming сессии

**Цель:** Моделирование домена через события
**Процесс:**
1. Выявление доменных событий (оранжевые стикеры)
2. Определение команд, которые их вызывают (синие)
3. Выделение аггрегатов (желтые границы)
4. Идентификация bounded contexts

### 6.3 Рефакторинг спринты

**Подход:**
- 1 спринт = 1 аспект DDD
- Например: "Спринт выделения Value Objects"
- Измерение прогресса через метрики кода

**Пример рефакторинг спринта:**
```
НЕДЕЛЯ 1: Выделение Value Objects
- День 1-2: Аудит примитивов в коде
- День 3-4: Создание VO для Email, Money, ProductCode
- День 5: Рефакторинг методов для использования VO

НЕДЕЛЯ 2: Enriching Entities
- День 1-2: Анализ anemic объектов
- День 3-4: Перенос логики из сервисов в entities
- День 5: Code review и тестирование
```

### 6.4 Архитектурные ADR (Architecture Decision Records)

**Формат:** Документирование каждого архитектурного решения
```markdown
# ADR-001: Выделение Order как отдельного аггрегата

## Статус
Принято

## Контекст
У нас есть логика заказов, размазанная по OrderService, 
PaymentService и InventoryService.

## Решение
Создаем Order аггрегат с четкими boundaries и инвариантами.

## Последствия
+ Четкие бизнес-правила
+ Лучшая тестируемость
- Нужно мигрировать существующий код
- Изменения в API
```

---

## 7. Трансформационный путь: от сервисов к домену

### 7.1 Фаза 1: Выявление проблем (2-4 недели)

**Цель:** Осознать текущие проблемы и увидеть альтернативу

**Активности:**
1. **Аудит текущего кода:**
   - Подсчет строк бизнес-логики в сервисах
   - Карта зависимостей между компонентами
   - Выявление дублирующейся логики

2. **DDD immersion:**
   - Чтение ключевых глав из "Domain-Driven Design" (Evans)
   - Просмотр видео с конференций
   - Анализ open-source проектов с DDD

3. **Проблемная идентификация:**
   - Список "code smells" в текущем коде
   - Трудности при добавлении новых фич
   - Сложности в тестировании

**Результат:** Понимание "что не так" и "что может быть лучше"

### 7.2 Фаза 2: Первые эксперименты (4-6 недель)

**Цель:** Попробовать DDD подходы на небольших примерах

**Активности:**
1. **Выделение простых Value Objects:**
```java
// Вместо String email везде
public record EmailAddress(String value) {
    public EmailAddress {
        if (!isValid(value)) {
            throw new InvalidEmailException(value);
        }
    }
    
    private boolean isValid(String email) {
        return email.contains("@") && email.length() > 5;
    }
}
```

2. **Создание первых поведенческих Entity:**
```java
public class Customer {
    private CustomerId id;
    private EmailAddress email;
    private CustomerStatus status;
    
    public void changeEmail(EmailAddress newEmail) {
        if (this.status == CustomerStatus.SUSPENDED) {
            throw new CustomerSuspendedException();
        }
        this.email = newEmail;
        // domain event можно добавить позже
    }
}
```

3. **Рефакторинг одного сервиса:**
   - Выбрать простейший сервис
   - Выделить доменную модель
   - Создать Application Service как оркестратор

**Результат:** Первый практический опыт с DDD паттернами

### 7.3 Фаза 3: Системный подход (6-8 недель)

**Цель:** Применить DDD к целому модулю/bounded context

**Активности:**
1. **Event Storming сессия:**
   - Моделирование одного bounded context
   - Выделение аггрегатов и их границ
   - Определение доменных событий

2. **Проектирование от Use Case:**
```java
// Начинаем с пользовательского сценария
@UseCase
public class PlaceOrderUseCase {
    
    @ApplicationService
    public OrderId handle(PlaceOrderCommand command) {
        // 1. Валидация на уровне приложения
        validateCommand(command);
        
        // 2. Загрузка аггрегатов
        Customer customer = customerRepo.findById(command.customerId());
        
        // 3. Доменная операция
        Order order = customer.placeOrder(
            command.products(), 
            command.deliveryAddress()
        );
        
        // 4. Сохранение
        orderRepo.save(order);
        
        // 5. Публикация событий
        domainEvents.publishAll(order.getEvents());
        
        return order.getId();
    }
}
```

3. **Внедрение CQRS:**
   - Разделение команд и запросов
   - Создание read моделей для UI
   - Проекции через доменные события

**Результат:** Полноценный DDD модуль

### 7.4 Фаза 4: Масштабирование и оптимизация (8+ недель)

**Цель:** Распространить DDD подходы на всю систему

**Активности:**
1. **Bounded Contexts mapping:**
   - Определение границ контекстов
   - Context mapping между командами
   - Стратегии интеграции

2. **Итеративный рефакторинг:**
   - Постепенное выделение новых аггрегатов
   - Пересмотр границ при новых требованиях
   - Эволюция доменной модели

3. **Автоматизация качества:**
   - ArchUnit тесты для проверки архитектуры
   - Метрики доменного покрытия
   - CI/CD с DDD валидациями

**Результат:** Зрелая DDD архитектура

---

## 8. Метрики прогресса трансформации

### 8.1 Количественные метрики

**Код структура:**
- % бизнес-логики в доменных объектах vs сервисах
- Количество Value Objects вместо примитивов
- Соотношение методов команд к запросам
- Количество доменных событий

**Качество:**
- Cyclomatic complexity доменных объектов
- Coupling между слоями архитектуры
- Code coverage доменных правил
- Количество дублирующихся бизнес-правил

**Пример отслеживания:**
```
Неделя 1: 5% логики в домене, 95% в сервисах
Неделя 8: 60% логики в домене, 40% в сервисах
Неделя 16: 85% логики в домене, 15% в сервисах (оркестрация)
```

### 8.2 Качественные индикаторы

**Ментальные модели:**
- Начинает проектирование с Use Cases, а не с БД
- Мыслит поведениями объектов, а не CRUD операциями
- Рассматривает trade-offs консистентности
- Не боится менять границы аггрегатов

**Коммуникация:**
- Использует доменный язык в обсуждениях
- Объясняет архитектурные решения через DDD принципы
- Предлагает доменные решения для бизнес-требований

**Пример качественной оценки:**
```
ВОПРОС: "Как добавить новое поле к заказу?"

ОТВЕТ УРОВНЯ 1: "Добавлю колонку в таблицу orders"

ОТВЕТ УРОВНЯ 3: "Сначала пойму, это новое поведение Order аггрегата 
или отдельной сущности? Если это влияет на инварианты заказа, 
то добавлю в Order. Если это просто метаданные для отчетности, 
то создам read-модель."
```

---

## 9. Распространенные препятствия и их преодоление

### 9.1 "Paralysis by Analysis"

**Проблема:** Слишком долго думает о "правильной" модели домена
**Решение:** 
- Начинать с простейшей модели, которая работает
- Рефакторинг через короткие итерации
- "Make it work, then make it right"

### 9.2 "Over-engineering"

**Проблема:** Создает сложные иерархии для простых задач
**Решение:**
- YAGNI принцип (You Aren't Gonna Need It)
- Начинать с простых POJO, усложнять по необходимости
- Помнить про business value каждого решения

### 9.3 "Legacy resistance"

**Проблема:** Существующий код сопротивляется DDD рефакторингу
**Решение:**
- Strangler Fig паттерн - постепенное замещение
- Анти-коррупционный слой для интеграции
- Новый код писать в DDD стиле, старый трогать только при необходимости

### 9.4 "Team alignment"

**Проблема:** Команда не понимает/не принимает DDD подходы
**Решение:**
- Shared learning sessions
- Code review с DDD фокусом
- Измеряемые результаты (скорость разработки, количество багов)

---

## 10. Интеграция с экстремальным программированием

### 10.1 Итеративный дизайн

**Принцип:** Проектируем ровно столько, сколько нужно для текущей итерации
**Практика:**
- Начинаем с простейшего аггрегата
- Добавляем сложность по мере появления новых требований
- Рефакторим границы аггрегатов, когда они становятся неудобными

### 10.2 Test-Driven Development + DDD

**Подход:**
1. Пишем тест для доменного поведения
2. Реализуем поведение в доменном объекте
3. Рефакторим для лучшей выразительности

**Пример:**
```java
@Test
void should_place_order_when_customer_has_sufficient_credit() {
    // Given
    Customer customer = Customer.withCredit(Money.of(1000));
    List<OrderLine> lines = List.of(
        OrderLine.of(productId, quantity, unitPrice)
    );
    
    // When
    Order order = customer.placeOrder(lines, deliveryAddress);
    
    // Then
    assertThat(order.getTotal()).isEqualTo(Money.of(500));
    assertThat(customer.getAvailableCredit()).isEqualTo(Money.of(500));
}
```

### 10.3 Рефакторинг как норма

**Ментальность:** Изменение границ аггрегатов - это нормальная практика
**Техники:**
- Extract Aggregate - выделение нового аггрегата
- Merge Aggregates - объединение слишком мелких
- Split Aggregate - разделение слишком большого
- Move Behavior - перенос поведения между объектами

---

## 11. Roadmap трансформации: 16 недель

### Недели 1-2: Диагностика
- Аудит текущего кода
- Выявление проблемных зон
- Изучение DDD принципов
- Постановка целей трансформации

### Недели 3-6: Первые шаги  
- Создание Value Objects
- Рефакторинг anemic entities
- Перенос простой логики из сервисов
- Code review с DDD фокусом

### Недели 7-10: Системный подход
- Event Storming для одного модуля
- Проектирование от Use Cases
- Внедрение Application Services
- Первые доменные события

### Недели 11-14: CQRS и консистентность
- Разделение команд и запросов
- Eventual consistency между аггрегатами
- Saga паттерны для сложных операций
- Read модели для UI

### Недели 15-16: Консолидация и планирование
- Ретроспектива трансформации
- Метрики достигнутого прогресса
- План дальнейшего развития
- Sharing опыта с командой

---

## 12. Заключение

Трансформация от сервис-ориентированного к домен-ориентированному мышлению - это не просто изучение новых паттернов, а фундаментальная смена подхода к проектированию программного обеспечения.

**Ключевые результаты трансформации:**
- Бизнес-логика живет в доменных объектах, а не размазана по сервисам
- Код выражает бизнес-концепты на языке предметной области
- Архитектура эволюционирует вместе с пониманием домена
- Разработчик уверенно принимает решения о границах и консистентности

**Критерий успешной трансформации:**
Когда при получении нового бизнес-требования первый вопрос не "в какую таблицу добавить поле?", а "как это изменение влияет на поведение доменных объектов и их границы?".

Эта трансформация дает разработчику инструменты для построения систем, которые растут и эволюционируют вместе с бизнесом, а не превращаются в legacy monster'ов после первого же изменения требований.