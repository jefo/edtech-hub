# UC-EPGEN-001 — Генерация эпизодов из дерева навыков (Skill Graph → Episodes)

## 0) Назначение

Формально описать Use Case, превращающий **граф навыков** (узлы = навыки/концепты, рёбра = зависимости) и **профили компетенций** (старт/цель) в **маршрут из эпизодов**, где каждый эпизод — это **единица трансформации (unlock)**: переход из состояния A→B по конкретному якорному навыку с проверкой мастерства.

---

## 1) Границы и уровень

- **Система:** Авторская платформа/пайплайн проектирования курса.
- **Уровень:** User-goal (уровень цели пользователя).
- **Область:** Competency-based design + DDD-ориентированное обучение.

---

## 2) Акторы

- **Primary:** Instructional Designer / Автор курса.
- **Supporting:** SME/Технический эксперт, Assessment Designer.
- **System Actor:** Episode Generator (сервис разметки/планирования).

---

## 3) Заинтересованные стороны и интересы

- **Автор:** Получить воспроизводимый, объяснимый план эпизодов.
- **Ученик:** Ясный прогресс и предсказуемые «unlock-и» навыков.
- **Бизнес:** Сократить время проектирования, повысить гарантию трансформации.

---

## 4) Предусловия

1. Доступен **Skill Graph**: \(G=(V,E)\), ориентированный ациклично (или отмечены циклы для ручного разрешения).
2. Определены **профили компетенций**:
   - **S₀** — стартовый (уровни владения по узлам \(V\)).
   - **S★** — целевой (уровни владения по подмножеству \(V_t\subseteq V\)).
3. Определены **параметры генерации**:
   - Порог **gapThreshold τ** (максимальная «ступень» между текущим владением и требуемым).
   - **Политики группировки** (на якорь/эпизод), когнитивная нагрузка (лимиты), длительность эпизода.
   - **Правила декомпозиции** навыков (scaffolding policy).
4. Доступен словарь уровней мастерства (например, 0..5) и типы узлов (concept/procedure/pattern/heuristic).

---

## 5) Постусловия (Success Guarantees)

1. Сформирован **упорядоченный список эпизодов** \(Eps = [Ep_1..Ep_n]\), удовлетворяющий зависимостям.
2. Каждый эпизод имеет **ровно один якорный навык** (Anchor Skill), набор поддерживающих (enabling) навыков, цели A→B, чекпоинт мастерства и артефакты.
3. Покрытие: все узлы целевого профиля \(V_t\) и их необходимые предпосылки **покрыты** хотя бы одним эпизодом.
4. Соблюдены лимиты нагрузки и длительности (или эпизоды разбиты).
5. Сгенерированы сопутствующие артефакты (скоуп задания, рубрика оценки, анти-паттерны, контент-брииф).

---

## 6) Триггер

Автор инициирует «Сгенерировать эпизоды из дерева навыков» для курса/модуля.

---

## 7) Основной сценарий (Main Success Scenario)

1. **Загрузка входов.** Система получает \(G, S₀, S★, τ\) и политики.
2. **Определение «нужного множества».** Вычислить \(R = closure(V_t)\) — транзитивное замыкание целевых узлов по зависимостям, затем исключить уже освоенные на требуемом уровне узлы из \(S₀\).
3. **Нормализация графа.** Проверить DAG; обнаружить циклы. При циклах — предложить авто-разрыв (ориентир по типам рёбер) или вернуть на ручное разрешение.
4. **Оценка разрывов (gap).** Для каждого \(v\in R\) рассчитать \(gap(v) = level_{target}(v) - level_{current}(v)\), скорректированный весами сложности.
5. **Scaffolding.** Если \(gap(v) > τ\), применить правила декомпозиции: разложить \(v\) на поднавыки \(Sub(v) = \{v_1..v_k\}\) и соответствующие рёбра; пометить как «вспомогательные». Повторять до \(gap\le τ\).
6. **Топологическая сортировка.** Получить порядок \(Topo(R)\) с учётом добавленных поднавыков.
7. **Формирование кандидатов эпизодов.** Идти по \(Topo(R)\); для каждого узла \(v\), если все его предпосылки покрыты, создать **кандидата эпизода** с якорем \(v\) и минимальным набором enabling-узлов, достаточным для unlock v.
8. **Группировка и паковка.** Применить эвристику «один якорь = один эпизод», добавить до \(k\) родственных микронодов, пока не превышены ограничения (длительность, нагрузка). Если превышены — **сплит** на \(Ep_i, Ep_{i+1}\).
9. **Присвоение метаданных.** Для каждого эпизода задать A→B формулировку, цели, артефакты (модель/схема/анти-паттерн), практику, рубрику, критерии прохождения (gate).
10. **Оптимизация маршрута.** Упорядочить эпизоды по:
    - минимизации переключений контекста,
    - возрастанию сложности,
    - максимизации повторного использования артефактов.
11. **Валидация покрытия.** Проверить, что все целевые узлы и необходимые предпосылки покрыты; вывести отчёт о пробелах/излишках.
12. **Генерация артефактов.** Выпустить Outline (TOC), Episode Design Sheets, Assessment Blueprint, Dependency Map.

---

## 8) Альтернативные и исключительные потоки

- **A1: Узел уже освоен.** Кандидат эпизода помечается «optional/challenge» или исключается.
- **A2: Циклические зависимости.** Просьба к автору вручную разорвать, либо авто-правило разворота по типу ребра.
- **A3: Недостающие предпосылки вне скоупа курса.** Авто-создание «Bridging Module» или отметка «внешняя ссылка/предтребование».
- **A4: Перегруз по когнитивной нагрузке.** Автосплит эпизода по кластерам узлов.
- **A5: Конфликт длительности.** Кнут–рюкзак разбиения по time budget; часть узлов переносится в следующий эпизод.

---

## 9) Бизнес‑правила и ограничения

1. **R1:** Один эпизод = один **Anchor Skill** (основной unlock).
2. **R2:** Enabling-узлов ≤ **k** (обычно 1–3) для удержания когнитивной нагрузки.
3. **R3:** Длительность эпизода: контент 12–20 мин + практика 10–30 мин.
4. **R4:** Эпизод публикуется только при наличии **gate‑оценки** (rubric + задача).
5. **R5:** Каждому узлу назначается **уровень мастерства** (0..5) и тип (concept/procedure/pattern/heuristic), влияющий на декомпозицию.
6. **R6:** Все зависимости якоря должны быть покрыты ранее или внутри эпизода в виде enabling.

---

## 10) Структура данных (контракты)

### 10.1 SkillNode

```json
{
  "id": "skill.aggregate.boundary",
  "name": "Aggregate Boundary Recognition",
  "type": "pattern",
  "levelTarget": 3,
  "complexity": 0.7,
  "prerequisites": ["skill.entity.vs.value", "skill.invariant"],
  "assessmentRubricId": "rubric.aggregate.boundary"
}
```

### 10.2 SkillEdge

```json
{
  "from": "skill.invariant",
  "to": "skill.aggregate.boundary",
  "relation": "prerequisite",
  "weight": 1.0
}
```

### 10.3 Profile (S₀/S★)

```json
{
  "skill.entity.vs.value": 2,
  "skill.invariant": 1,
  "skill.aggregate.boundary": 0
}
```

### 10.4 Episode

```json
{
  "id": "ep-07",
  "anchorSkillId": "skill.aggregate.boundary",
  "enablingSkills": ["skill.entity.vs.value", "skill.invariant"],
  "entryState": "A: различает сущности и VO на примерах, не умеет выделять инварианты",
  "exitState": "B: определяет границы агрегата через инварианты и консистентность",
  "artifacts": ["schema.aggregate.boundary.svg", "code.sample.aggregate.ts"],
  "antiPatterns": ["anemic_domain_model", "god_aggregate"],
  "practiceTask": "Наметить агрегаты и инварианты для модуля заказов",
  "assessmentRubricId": "rubric.aggregate.boundary",
  "timeBudget": {"contentMin": 18, "practiceMin": 20}
}
```

---

## 11) Алгоритм (формально + псевдокод)

### 11.1 Метрики

- `gap(v) = max(0, targetLevel(v) - currentLevel(v)) * complexity(v)`
- Ограничения: `maxEnabling = k`, `episodeTime ≤ T`, `cognitiveLoad ≤ C`.

### 11.2 Псевдокод

```pseudo
INPUT: Graph G=(V,E), Profile S0, Target S*, τ, Policies P
OUTPUT: Ordered Episodes Eps

R <- closure_of_targets(G, S*)                  // обязательные узлы
R <- remove_mastered(R, S0, S*)                 // уже освоенные на нужном уровне

for v in R:
    if gap(v) > τ:
        Sub(v) <- decompose(v, policy=P.scaffold) // добавить поднавыки и рёбра
        G <- integrate(G, Sub(v))
        R <- R ∪ Sub(v)

Topo <- topological_sort(G restricted to R)
Eps <- []

for v in Topo:
    if prereqs_covered(v, Eps, S0):
        ep <- new Episode(anchor=v)
        ep.enabling <- select_minimal_enabling(v, G, limits={k, C, T})
        if exceeds_limits(ep):
            ep <- split(ep, strategy=P.split)
        enrich_with_metadata(ep)  // A→B, artifacts, tasks, rubrics
        Eps.append(ep)

Eps <- optimize_order(Eps, objectives=[low_context_switch, rising_difficulty, reuse])
validate_coverage(Eps, R)
return Eps
```

---

## 12) Политики декомпозиции (Scaffolding Policy)

- **By Bloom:** понизить уровень (Evaluate→Analyze→Apply→Understand→Remember) и выделить поднавыки.
- **By Type:** pattern → раскрыть через concept + procedure + heuristic.
- **By Invariant:** если узел зависит от неявных инвариантов — выделить их как явные подузлы.
- **By Example:** добавить минимум 1 «рабочий» пример и 1 анти‑пример как отдельные микро‑узлы практики.

---

## 13) Эвристики группировки (Packing)

1. Один эпизод — один Anchor.
2. Enabling добавляем по принципу **минимально достаточного набора**.
3. Предпочитать «вертикальный срез» (from prereq to anchor) вместо горизонтальной свалки.
4. Если узлы разных типов, порядок внутри эпизода: concept → procedure → pattern → heuristic → практика → gate.

---

## 14) Нефункциональные требования

- **Повторяемость:** одинаковые входы → одинаковые эпизоды.
- **Объяснимость:** лог генерации (почему выбран такой enabling, почему сплит).
- **Версионирование:** снапшот дерева и профилей сохраняется с выпуском.
- **Идемпотентность:** повторный запуск поверх текущего плана делает только детерминированные корректировки.

---

## 15) KPI/Метрики качества маршрута

- % целевых узлов, покрытых прошедшими gate.
- Среднее число попыток на gate (целевое ≤ 2).
- Доля эпизодов, не потребовавших сплит после пилота.
- Time-to-design (автоматизация экономит ≥ X%).

---

## 16) Пример (DDD, мини-граф)

**Узлы:**

- `entity_vs_value (target=3)`
- `invariants (target=2)`
- `consistency_boundary (target=2)`
- `aggregate_boundary (target=3)` ← Anchor

**Рёбра:**

- `entity_vs_value → aggregate_boundary`
- `invariants → aggregate_boundary`
- `consistency_boundary → aggregate_boundary`

**S₀:** `{entity_vs_value:2, invariants:1, consistency_boundary:0, aggregate_boundary:0}`

**τ=1** ⇒ декомпозиция `consistency_boundary` на `consistency_types` + `transactional_boundary` (оба target=1..2).

**Эпизоды (результат):**

1. **EP-05 (Anchor: consistency\_boundary)** enabling: `consistency_types`, `transactional_boundary`.
2. **EP-06 (Anchor: invariants)** enabling: мини‑практика «сформулируй инварианты заказа».
3. **EP-07 (Anchor: aggregate\_boundary)** enabling: `entity_vs_value` (refresh), `invariants`, `consistency_boundary`.

---

## 17) Шаблон «Лист дизайна эпизода» (Episode Design Sheet)

- **ID / Anchor Skill:**
- **A→B (единая фраза трансформации):**
- **Enabling Skills (минимально достаточные):**
- **Модель/Артефакт:** схема/код/визуализация.
- **Анти‑паттерны:**
- **Практика:** реальный мини‑кейс, ожидания.
- **Gate (оценивание):** критерии, рубрика, пороги.
- \*\*Вре
